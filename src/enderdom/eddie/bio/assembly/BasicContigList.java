package enderdom.eddie.bio.assembly;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;

import org.apache.log4j.Logger;

import enderdom.eddie.bio.lists.Fasta;
import enderdom.eddie.bio.sequence.BioFileType;
import enderdom.eddie.bio.sequence.Contig;
import enderdom.eddie.bio.sequence.ContigList;
import enderdom.eddie.bio.sequence.UnsupportedTypeException;

public class BasicContigList implements ContigList{

	ArrayList<Contig> records;
	int iteration =0;
	Logger logger = Logger.getRootLogger();
	
	public BasicContigList(){
		records = new ArrayList<Contig>();
	}
	
	public BasicContigList(ArrayList<Contig> list){
		records = list;
	}

	public BasicContigList(File f, BioFileType t) throws Exception{
		records = new ArrayList<Contig>();
		load(f, t);
	}
	
	public BasicContigList(File f, File f2, BioFileType t) throws Exception{
		records = new ArrayList<Contig>();
		load(f, f2, t);
	}
	
	private void parseAce(File f) throws IOException{
		ACEFileParser parser = new ACEFileParser(f);
		logger.debug("Parser claims file has " + parser.getContigSize()+ " contigs");
		records = new ArrayList<Contig>(parser.getContigSize());
		int c=0;
		while(parser.hasNext()){
			System.out.print("\rParsing record "+(c+1)+ " of "+ parser.getContigSize()+"    " );
			records.add((Contig)parser.next());
			c++;
		}
		System.out.println();
		logger.debug("Parser gave us " + c+ " contigs");
	}
	
	public static Contig[] List2RecordArray(List<Contig> list){
		Contig[] records = new Contig[list.size()];
		for(int i =0; i < list.size();i++)records[i]=list.get(i);
		return records;
	}

	public boolean hasNext() {
		return iteration < this.records.size();
	}

	public Contig next() {
		iteration++;
		return records.get(iteration-1);
	}

	public void remove() {
		this.records.remove(iteration);
	}

	public Contig getContig(String name) {
		for(int i=0; i < records.size(); i++){
			if(records.get(i).getConsensus().getIdentifier().contentEquals(name)){
				return records.get(i);
			}
		}
		return null;
	}

	public Contig getContig(int i) {
		return records.get(i);
	}

	public String[] getContigNames() {
		String[] names = new String[records.size()];
		for(int i =0; i < names.length ;i++)names[i]=records.get(i).getConsensus().getIdentifier();
		return names;
	}

	public LinkedHashMap<String, String> getConsensusAsMap() {
		LinkedHashMap<String, String> map = new LinkedHashMap<String, String>();
		for(int i =0; i < records.size();i++){
			map.put(records.get(i).getConsensus().getIdentifier(), records.get(i).getConsensus().getSequence());
		}
		return map;
	}

	public int getNoOfContigs() {
		return records.size();
	}

	public void addContig(Contig c) {
		this.records.add(c);
	}

	public void save(File f, BioFileType t) throws Exception{
		if(t == BioFileType.ACE){
			new ACEWriter().save(this, f);
		}
		else if(t == BioFileType.FASTA){
			Fasta fasta =new Fasta();
			for(Contig r : this.records){
				fasta.addSequence(r.getContigName(), r.getConsensus().getSequence().replaceAll("\\*", ""));
			}
			fasta.saveFile(f, t);
		}
		else throw new UnsupportedTypeException("Biofile type is not ACEm do not support " + t.toString());
	}

	public void load(File f, BioFileType t) throws Exception {
		if(t == BioFileType.ACE){
			parseAce(f);
		}
		else if(t == BioFileType.SAM || t == BioFileType.BAM){
			logger.warn("Warning no accompanying reference/consensus fasta file, SAM data will not have consensus sequence");
			logger.warn("Use reference sequences generated by assembler or use samtools to generate consensus (@see samtools mpileup)");
			this.records = SAMParseWrapper.parseSAM(f, null);
		}
		else throw new UnsupportedTypeException("Biofile type is not ACE or SAM, do not support " + t.toString());
	}

	public void load(File f, File f2, BioFileType t) throws Exception {
		if(t == BioFileType.ACE){
			parseAce(f);
		}
		else if(t == BioFileType.SAM || t == BioFileType.BAM){
			logger.warn("Warning no accompanying reference/consensus fasta file, SAM data will not have consensus sequence");
			logger.warn("Use reference sequences generated by assembler or use samtools to generate consensus (@see samtools mpileup)");
			this.records = SAMParseWrapper.parseSAM(f, f2);
		}
		else throw new UnsupportedTypeException("Biofile type is not ACE or SAM, do not support " + t.toString());
	}

	public int getNoOfReads() {
		int sum =0;
		Iterator<Contig> contigs = this.records.iterator();
		while(contigs.hasNext())sum+=contigs.next().getNoOfSequences();
		return sum;
	}
}
