package enderdom.eddie.bio.assembly;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;

import org.apache.log4j.Logger;

import enderdom.eddie.bio.sequence.BasicRegion;
import enderdom.eddie.bio.sequence.Contig;
import enderdom.eddie.tools.Tools_String;
import enderdom.eddie.tools.Tools_System;
import enderdom.eddie.tools.bio.Tools_Fasta;
import enderdom.eddie.ui.EddiePropertyLoader;

public class ACEWriter {
	
	String newline;
	public String acedateformat = "EEE MMM HH:mm:ss yyyy";
	private String date;
	private boolean writeDS = true;
	private boolean writeCT = true; 
	private static int acebase = 1;
	private int linelength = 60;
	private int perc;
	private int size;
	private int readcount;
	private boolean printprogress;
	private boolean headerwritten;
	Logger logger;
	private BufferedWriter local;
	private String CTString;
	
	public ACEWriter(){
		init();
	}
	
	public ACEWriter(File f) throws IOException{
		init();
		setBufferedWriter(f);
	}
	
	
	public void init(){
		date = Tools_System.getDateNow(acedateformat);
		newline = Tools_System.getNewline();
		perc=0;
		readcount=0;
		logger = Logger.getRootLogger();
		printprogress = true;
		CTString = "Output generated by Eddie v"+EddiePropertyLoader.getFullVersion()+" see https://github.com/EnderDom/Eddie";
	}
	

	public void setBufferedWriter(File f) throws IOException{
		local = new BufferedWriter(new FileWriter(f));
	}
	
	
	public void save(BasicContigList list, File f) throws IOException {
		logger.info("Writing to File at "+f.getPath());
		FileWriter fstream = new FileWriter(f);
		BufferedWriter out = new BufferedWriter(fstream);
		//Write AS header
		size = list.getNoOfReads();
		writeHeader(list.getNoOfContigs(), size, out);
		//Loop Through Contigs	
		for(String name : list.getContigNames()){
			Contig c = list.getContig(name);
			writeContig(c, out);
		}
		if(printprogress)System.out.println("\r100% written      ");
		closeAce(out);
	}
	
	public void closeAce() throws IOException{
		closeAce(local);
	}
	
	public void closeAce(BufferedWriter out) throws IOException{
		logger.info("File written.");
		out.flush();
		out.close();
	}
	
	public void writeHeader(int contigcount, int readcount) throws IOException{
		writeHeader(contigcount, readcount, local);
	}
	
	public void writeHeader(int contigcount, int readcount, BufferedWriter out) throws IOException{
		out.write(getASHeader(contigcount, readcount));
		headerwritten=true;
	}
	
	public int writeContig(Contig c) throws IOException{
		return writeContig(c, local);
	}
	
	public int writeContig(Contig c, BufferedWriter out) throws IOException{
		if(!headerwritten){
			logger.error("ACE header has not been written!");
		}
		int localreadcount =0;
		String name = c.getContigName();
		out.write(getCOHeader(c));
		Tools_String.splitintolinesandsave(linelength, c.getConsensus().getSequence(), out);
		out.write(newline);
		out.write("BQ ");
		out.write(newline);
		if(c.isNoQual2fastq()){
			out.write(Tools_Fasta.Fastq2QualwNewline4ACE(c.getConsensus().getQuality(), linelength));
		}
		else{
			out.write(Tools_Fasta.QualwNewline(c.getConsensus().getQuality(), linelength));
		}
		
		out.write(newline);
		out.write(newline);
		//Loop Through Reads
		for(String read :c.getReadNames()){
			out.write(getAFHeader(read, name, c));
		}
		for(BasicRegion r : c.getRegions()){
			out.write(getBSHeader(r));
		}
		for(String read : c.getReadNames()){
			out.write(newline);
			out.write(getRDHeader(read, name, c));
			Tools_String.splitintolinesandsave(linelength, c.getSequence(read).getSequence(), out);
			out.write(newline);
			out.write(getQAHeader(read, name, c));
			if(writeDS){
				out.write(getDSHeader());
			}
			out.write(newline);
			readcount++;
		}
		if(writeCT){
			out.write(getCTHeader());
		}
		readcount+=localreadcount;
		if(printprogress && readcount%10==0)writeUpdate();
		return localreadcount;
	}
	
	private void writeUpdate(){
		perc = (int)((double)readcount/size*100);
		System.out.print("\r"+perc + "% written  "+Tools_String.getCounter()+"  ");
	}

	private String getCTHeader() {
		StringBuffer buffer = new StringBuffer();
		buffer.append("CT{");
		buffer.append(newline);
		buffer.append(CTString);
		buffer.append(newline);
		buffer.append("}");
		buffer.append(newline);
		buffer.append(newline);
		return buffer.toString();
	}

	private String getDSHeader() {
		StringBuffer buffer = new StringBuffer();
		buffer.append("DS VERSION: 1 TIME: ");
		buffer.append(date);
		buffer.append(newline);
		return buffer.toString();
	}

	private String getQAHeader(String read, String name,
			Contig c) {
		StringBuffer buffer = new StringBuffer();
		buffer.append("QA " );
		int[] range = c.getRange(read, acebase);
		buffer.append(range[0]);
		buffer.append(" ");
		buffer.append(range[1]);
		range = c.getPaddedRange(read, acebase);
		buffer.append(" ");
		buffer.append(range[0]);
		buffer.append(" ");
		buffer.append(range[1]);
		buffer.append(newline);
		return buffer.toString();
	}

	private String getRDHeader(String read, String name,
			Contig c) {
		StringBuffer buffer =  new StringBuffer();
		buffer.append("RD ");
		buffer.append(read);
		buffer.append( " ");
		buffer.append(c.getSequence(read).getLength());
		buffer.append(" 0 0");
		buffer.append(newline);
		return buffer.toString();
	}

	private  String getBSHeader(BasicRegion r) {
		StringBuffer buffer =  new StringBuffer();
		buffer.append("BS ");
		buffer.append(r.getStart(1));
		buffer.append(" ");
		buffer.append(r.getStop(1));
		buffer.append(" ");
		buffer.append(r.getName());
		buffer.append(newline);
		return buffer.toString();
	}

	private String getAFHeader(String read, String name,
			Contig c) {
		StringBuffer buffer = new StringBuffer();
		buffer.append("AF ");
		buffer.append(read);
		buffer.append(" " );
		buffer.append(c.getCompliment(read));
		buffer.append(" " );
		buffer.append(c.getOffset(read, acebase));
		buffer.append(newline);
		return buffer.toString();
	}

	private String getCOHeader(Contig contig) {
		StringBuffer buffer = new StringBuffer();
		buffer.append("CO ");
		buffer.append(contig.getContigName());
		buffer.append(" "+contig.getConsensus().getLength());
		buffer.append(" "+contig.getNoOfSequences());
		buffer.append(" "+contig.getRegions().size());
		buffer.append(" " + contig.getConsensusCompliment());
		buffer.append(newline);
		return buffer.toString();
	}

	private String getASHeader(int contigcount, int readcount) {
		StringBuffer buffer = new StringBuffer();
		buffer.append("AS ");
		buffer.append(contigcount);
		buffer.append(" ");
		buffer.append(readcount);
		buffer.append(newline);
		buffer.append(newline);
		return buffer.toString();
	}

	
	public boolean isWriteDS() {
		return writeDS;
	}

	public void setWriteDS(boolean writeDS) {
		this.writeDS = writeDS;
	}

	public boolean isWriteCT() {
		return writeCT;
	}

	public void setWriteCT(boolean writeCT) {
		this.writeCT = writeCT;
	}

	public int getLinelength() {
		return linelength;
	}

	public void setLinelength(int linelength) {
		this.linelength = linelength;
	}


	public boolean isPrintprogress() {
		return printprogress;
	}

	public void setPrintprogress(boolean printprogress) {
		this.printprogress = printprogress;
	}

	public String getCTString() {
		return CTString;
	}

	public void setCTString(String cTString) {
		CTString = cTString;
	}
	
}
